from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import numpy as np
import pandas as pd
import joblib
import os

from flask_jwt_extended import (
    JWTManager,
    create_access_token,
    create_refresh_token,
    jwt_required,
    get_jwt_identity
)

from flask_bcrypt import Bcrypt
from models import db, User
from ai_chat import ask_ollama

app = Flask(__name__)

# ================= CONFIG =================
CORS(app)

app.config["JWT_SECRET_KEY"] = os.getenv(
    "JWT_SECRET_KEY",
    "attendance_ai_super_secure_random_key_2026_long_enough"
)

app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///attendance.db"
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = 15 * 60
app.config["JWT_REFRESH_TOKEN_EXPIRES"] = 7 * 24 * 60 * 60

jwt = JWTManager(app)
bcrypt = Bcrypt(app)

db.init_app(app)

with app.app_context():
    db.create_all()

uploaded_csv_text = ""

print("âœ… app.py loaded")

# ================= LOAD ML MODEL =================
model = joblib.load("attendance_model.pkl")
scaler = joblib.load("scaler.pkl")

# ================= TEST ROUTE =================
@app.route("/")
def home():
    return "Backend running successfully"

# ================= SIGNUP =================
@app.route("/signup", methods=["POST"])
def signup():
    data = request.get_json()

    if User.query.filter_by(email=data.get("email")).first():
        return jsonify({"message": "User already exists"}), 400

    hashed = bcrypt.generate_password_hash(data["password"]).decode("utf-8")

    user = User(
        name=data["name"],
        email=data["email"],
        password=hashed
    )

    db.session.add(user)
    db.session.commit()

    return jsonify({"message": "Signup successful"})


# ================= LOGIN =================
@app.route("/login", methods=["POST"])
def login():
    data = request.get_json()

    user = User.query.filter_by(email=data.get("email")).first()

    if not user or not bcrypt.check_password_hash(user.password, data.get("password")):
        return jsonify({"message": "Invalid credentials"}), 401

    access_token = create_access_token(identity=user.id)
    refresh_token = create_refresh_token(identity=user.id)

    return jsonify({
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user": {
            "id": user.id,
            "name": user.name,
            "email": user.email
        }
    })


# ================= TOKEN REFRESH =================
@app.route("/refresh", methods=["POST"])
@jwt_required(refresh=True)
def refresh():
    user_id = get_jwt_identity()
    new_access_token = create_access_token(identity=user_id)

    return jsonify({
        "access_token": new_access_token
    })


# ================= MANUAL PREDICTION =================
@app.route("/predict-manual", methods=["POST"])
def predict_manual():
    data = request.get_json()

    X = np.array([[data["attendance"], data["late"], data["leaves"]]])
    X_scaled = scaler.transform(X)

    prediction = model.predict(X_scaled)[0]

    risk_map = {
        0: "Low Risk",
        1: "Medium Risk",
        2: "High Risk"
    }

    return jsonify({
        "risk": risk_map.get(int(prediction), "Unknown"),
        "reason": "Prediction generated by ML model"
    })


# ================= CSV PREDICTION =================
@app.route("/predict-csv", methods=["POST"])
def predict_csv():
    try:
        file = request.files["file"]
        df = pd.read_csv(file)

        # Normalize column names
        df.columns = (
            df.columns.str.lower()
            .str.replace(" ", "")
            .str.replace("_", "")
            .str.replace("%", "")
        )

        # -------- SMART COLUMN FINDER --------
        def find_col(keys):
            for col in df.columns:
                for k in keys:
                    if k in col:
                        return col
            return None

        attendance_col = find_col([
            "attendance", "attend", "present", "dayspresent"
        ])

        late_col = find_col([
            "late", "latedays"
        ])

        leaves_col = find_col([
            "leave", "leaves", "absent", "leavestaken"
        ])

        if not all([attendance_col, late_col, leaves_col]):
            return jsonify({
                "error": "CSV must include attendance, late days and leaves columns"
            }), 400

        def clean(col):
            return (
                col.astype(str)
                .str.replace("%", "")
                .replace("", "0")
                .replace("nan", "0")
                .astype(float)
            )

        # ---- STANDARDIZE TO MODEL FEATURES ----
        X = pd.DataFrame({
            "dayspresent": clean(df[attendance_col]),
            "latedays": clean(df[late_col]),
            "leavestaken": clean(df[leaves_col])
        })

        print("Detected Columns:", attendance_col, late_col, leaves_col)
        print("Feature Shape:", X.shape)

        X_scaled = scaler.transform(X)

        preds = model.predict(X_scaled)

        def normalize_prediction(p):
            risk_map = {
                0: "Low Risk",
                1: "Medium Risk",
                2: "High Risk"
            }
            return risk_map.get(int(p), "Unknown")

        df["Predicted_Risk"] = [normalize_prediction(p) for p in preds]

        output = "attendance_prediction.csv"
        df.to_csv(output, index=False)

        return send_file(output, as_attachment=True)

    except Exception as e:
        print("CSV ERROR:", e)
        return jsonify({"error": str(e)}), 500


# ================= STORE CSV FOR CHATBOT =================
@app.route("/upload-data", methods=["POST"])
def upload_data():
    global uploaded_csv_text

    uploaded_csv_text = request.json.get("text", "")

    return jsonify({"message": "CSV data stored for AI chatbot"})


# ================= CHATBOT =================
@app.route("/chat", methods=["POST"])
def chat():
    try:
        data = request.json or {}
        question = data.get("message", "")

        if not question:
            return jsonify({"reply": "Please ask a question."})

        answer = ask_ollama(question, uploaded_csv_text)

        return jsonify({
            "reply": answer
        })

    except Exception as e:
        print("CHAT API ERROR:", e)
        return jsonify({"reply": str(e)}), 500


# ================= LOGOUT =================
@app.route("/logout", methods=["POST"])
@jwt_required()
def logout():
    return jsonify({"message": "Logged out successfully"})


# ================= RUN SERVER =================
if __name__ == "__main__":
    app.run(port=5000)
